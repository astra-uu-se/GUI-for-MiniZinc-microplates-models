# Copyright 2025 Ramiz Gindullin.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Description:  Various supplementary utilities related to reading the config file
#
# Authors: Ramiz GINDULLIN (ramiz.gindullin@it.uu.se)
# Version: 1.0
# Last Revision: October 2025
#


import os
import logging

from typing import Tuple, List

from models.constants import Performance, Validation, PathsIni, Visualization
from models.dto import AppConfig


logger = logging.getLogger(__name__)


def load_config() -> AppConfig:
    """Read and parse paths.ini configuration file.
    
    Returns:
        Validated AppConfig object
        
    Raises:
        FileNotFoundError: If paths.ini file cannot be read
    """
    logger.debug("Loading configuration from paths.ini")
    try:
        with open('config/paths.ini', 'r') as file:
            paths_array = file.readlines()
    except (FileNotFoundError, IOError) as e:
        logger.error(f"Cannot read paths.ini file: {e}")
        raise FileNotFoundError("Could not read paths.ini file. Please ensure it exists and is readable.") from e
    
    # Initialize variables with defaults
    minizinc_path = plaid_path = compd_path = plaid_mpc_path = compd_mpc_path = ""
    
    for line in paths_array:
        line_clean = line.strip()
        if len(line_clean) == 0:
            pass
        elif line_clean[0] == "#":
            pass
        else:
            try:
                [left_side, right_side] = line_clean.split('=')
                left_side = left_side.strip()
                right_side = right_side.strip()
            except:
                raise ValueError(line_clean)
            
            if left_side == PathsIni.MINIZINC_PREFIX:
                minizinc_path = right_side.strip()[1:-1]
            elif left_side == PathsIni.PLAID_PREFIX:
                plaid_path = right_side.strip()[1:-1]
            elif left_side == PathsIni.COMPD_PREFIX:
                compd_path = right_side.strip()[1:-1]
            elif left_side == PathsIni.PLAID_MPC_PREFIX:
                plaid_mpc_path = right_side.strip()[1:-1]
            elif left_side == PathsIni.COMPD_MPC_PREFIX:
                compd_mpc_path = right_side.strip()[1:-1]
    
    app_config = AppConfig(minizinc_path= minizinc_path,
                           plaid_path = plaid_path,
                           compd_path = compd_path,
                           plaid_mpc_path = plaid_mpc_path,
                           compd_mpc_path = compd_mpc_path)
    
    # Validate configuration
    validation_errors = validate_config(app_config)
    if validation_errors:
        # Format user-friendly error message
        numbered_errors = '\n'.join(f"  {i+1}. {error}" for i, error in enumerate(validation_errors))
        error_msg = (
            "Configuration validation failed:\n\n"
            f"{numbered_errors}\n\n"
            "Please check your config/paths.ini file and ensure all paths are correct.\n"
            "Common solutions:\n"
            "  • Install MiniZinc and update the path\n"
            "  • Check that all .mzn and .mpc files exist\n"
            "  • Verify file permissions are readable"
        )
        raise ValueError(error_msg)
    
    logger.info("Configuration loaded successfully from paths.ini")
    return app_config


def validate_config(cfg: AppConfig) -> List[str]:
    """Validate configuration and return list of error messages.
    (generated by Perplexity AI)
    
    Args:
        cfg: Configuration object to validate
        
    Returns:
        List of validation error messages (empty if valid)
    """
    import os
    from pathlib import Path
    
    errors: List[str] = []
    
    # Helper function for file existence checks
    def path_exists(path_str: str) -> bool:
        if not path_str or not path_str.strip():
            return False
        try:
            return Path(path_str).exists()
        except (OSError, ValueError):
            return False
    
    def is_executable(path_str: str) -> bool:
        if not path_exists(path_str):
            return False
        try:
            path_obj = Path(path_str)
            # On Windows, check if it's a .exe file or has executable permission
            if os.name == 'nt':
                return path_obj.suffix.lower() in ['.exe', '.bat', '.cmd'] or os.access(path_obj, os.X_OK)
            else:
                return os.access(path_obj, os.X_OK)
        except (OSError, ValueError):
            return False
    
    # Validate MiniZinc path (must be executable)
    if not cfg.minizinc_path or not cfg.minizinc_path.strip():
        errors.append("MiniZinc path is empty or not set")
    elif not path_exists(cfg.minizinc_path):
        errors.append(f"MiniZinc executable not found at: '{cfg.minizinc_path}'")
    elif not is_executable(cfg.minizinc_path):
        errors.append(f"MiniZinc path exists but is not executable: '{cfg.minizinc_path}'")
    
    # Validate model and config files (must exist and be readable)
    file_checks = [
        ("PLAID model file", cfg.plaid_path),
        ("COMPD model file", cfg.compd_path),
        ("PLAID solver config", cfg.plaid_mpc_path),
        ("COMPD solver config", cfg.compd_mpc_path),
    ]
    
    for file_desc, file_path in file_checks:
        if not file_path or not file_path.strip():
            errors.append(f"{file_desc} path is empty or not set")
        elif not path_exists(file_path):
            errors.append(f"{file_desc} not found at: '{file_path}'")
        # Optional: check if file is readable
        elif not os.access(Path(file_path), os.R_OK):
            errors.append(f"{file_desc} exists but is not readable: '{file_path}'")
    
    return errors